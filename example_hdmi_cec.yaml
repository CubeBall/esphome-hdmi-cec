esphome:
  name: cec
  platform: ESP8266
  board: d1_mini
  platformio_options:
    # Because of the inefficient CEC library I'm using, I can't send/receive CEC commands
    # while having WiFi enabled. Perhaps more cpu will help.
    board_build.f_cpu: 160000000L
  on_boot:
    priority: 0
    then:
      - delay: 2s
      - hdmi_cec.send:
          source: 0x05
          destination: 0x0
          data: [ 0x04 ]

# wifi:
#   ssid: !secret wifi_ssid
#   password: !secret wifi_password
#   fast_connect: true

# Enable logging
logger:

# ota:

external_components:
  - source: ./components

# output:
#   - platform: gpio
#     pin: D1
#     id: gpio_d1
#     mode: open_drain

    # } else if (count == 2) {
    #     if (buffer[1] == 0x41) {
    #         DbgPrint("vol up\n");
    #     } else if (buffer[1] == 0x42) {
    #         DbgPrint("vol down\n");
    #     } else if (buffer[1] == 0x43) {
    #         DbgPrint("vol mute\n");
    #     }
    # } else if (count == 3) {
    #     // System audio mode request
    #     if (buffer[0] = 0x70 && buffer[1]==0x00 && buffer[2] == 0x00) {
            
    #         DbgPrint("System audio mode response\n");
    #         unsigned char buffer[] = {0x50,0x72,0x01};
    #         ceclient.TransmitFrame(0, buffer, 3);        

    #     }
    # }

hdmi_cec:
  address: 0x05
  pin: 4
  on_message:
    - opcode: 0xC3 # Request ARC start
      then:
        - hdmi_cec.send: # Report ARC started
            destination: 0x0
            data: [ 0xC1 ]
    - opcode: 0x70 # System audio mode request
      then:
        - hdmi_cec.send:
            destination: 0x0
            data: [ 0x50, 0x72, 0x01 ]
    - opcode: 0x71 # Give audio status
      then:
        - hdmi_cec.send:
            destination: 0x0
            data: [ 0x00, 0x71, 0x04 ]
    - opcode: 0x7D # Give audio system mode status
      then:
        - hdmi_cec.send:
            destination: 0x0
            data: [ 0x7E, 0x01 ]
    - opcode: 0x46 # Give OSD name
      then:
        - hdmi_cec.send:
            destination: 0x0
            data: [0x47, 0x65, 0x73, 0x70, 0x68, 0x6F, 0x6D, 0x65]
    - opcode: 0x8C # Give device Vendor ID
      then:
        - hdmi_cec.send:
            destination: 0x0
            data: [0x87, 0x00, 0x13, 0x37]
    - data: [0x44, 0x41] # User control pressed: volume up
      then:
        - logger.log: "Volume up"
    - data: [0x44, 0x42] # User control pressed: volume down
      then:
        - logger.log: "Volume down"
    - data: [0x44, 0x43] # User control pressed: volume mute
      then:
        - logger.log: "Volume mute"

button:
  - platform: template
    name: TV Turn Onnnn
    on_press:
      - hdmi_cec.send:
          source: 0x05
          destination: 0x0
          data: [ 0x04 ]
      - logger.log: "Button pressed"

# Enable Home Assistant API
# api:
  # services:
  #   - service: transmit_cec
  #     variables:
  #       source: int
  #       destination: int
  #       data: int[]
  #     then:
  #       - hdmi_cec.send:
  #           # source: !lambda 'return source;'
  #           destination: !lambda 'return destination;'
  #           data: !lambda 'return data;'

    # I'm not sure how to use jinja {% if %} statements and return an int,
    # So instead I'm using an alternate method that accepts a string for command
  #   - service: transmit_nec_string
  #     variables:
  #       address: int
  #       command: string
  #     then:
  #       - remote_transmitter.transmit_nec:
  #           address: !lambda 'return address;'
  #           command: !lambda 'return (int)strtol(command.c_str(), NULL, 16);'
  #   - service: transmit_raw
  #     variables:
  #       code: int[]
  #       carrier_frequency: float
  #     then:
  #       - remote_transmitter.transmit_raw:
  #           code: !lambda 'return code;'
  #           carrier_frequency: !lambda 'return carrier_frequency;'
  #   - service: transmit_raw_repeat
  #     variables:
  #       code: int[]
  #       carrier_frequency: float
  #       repeat_times: int
  #       repeat_wait_time_us: int
  #     then:
  #       - remote_transmitter.transmit_raw:
  #           code: !lambda 'return code;'
  #           carrier_frequency: !lambda 'return carrier_frequency;'
  #           repeat:
  #             times: !lambda 'return repeat_times;'
  #             wait_time: !lambda 'return repeat_wait_time_us;'
