esphome:
  name: cec
  platform: ESP8266
  board: d1_mini
  on_boot:
    priority: 0
    then:
      - delay: 2s
      - hdmi_cec.send:
          source: 0x05
          destination: 0x0
          data: [ 0x04 ]

# wifi:
#   ssid: !secret wifi_ssid
#   password: !secret wifi_password
#   fast_connect: true

# Enable logging
logger:

# ota:

external_components:
  - source: ./components

# output:
#   - platform: gpio
#     pin: D1
#     id: gpio_d1
#     mode: open_drain

hdmi_cec:
  source: 0x05
  on_packet:
    - opcode: 0xC3 # Request ARC start
      then:
        - lambda: |-
            ESP_LOGD("asdf", "arc start");
    - opcode: 0x70 # System audio mode request
      then:
        - lambda: |-
            ESP_LOGD("asdf", "System audio mode request");      
    - opcode: 0x71 # Give audio status
      then:
        - lambda: |-
            ESP_LOGD("asdf", "audio status");
    - opcode: 0x7D # Give audio system mode status
      then:
        - lambda: |-
            ESP_LOGD("asdf", "system mode status");
    - opcode: 0x46 # What's your name
      then:
        - lambda: |-
            ESP_LOGD("asdf", "name request");
    - opcode: 0x8C # What's your vendorid
      then:
        - lambda: |-
            ESP_LOGD("asdf", "vendorid request");
    - opcode: 0x41 # vol up
      then:
        - lambda: |-
            ESP_LOGD("asdf", "vendorid request");
    - opcode: 0x42 # vol down
      then:
        - lambda: |-
            ESP_LOGD("asdf", "vendorid request");
    - opcode: 0x43 # vol mute
      then:
        - lambda: |-
            ESP_LOGD("asdf", "vendorid request");

button:
  - platform: template
    name: TV Turn Onnnn
    on_press:
      - hdmi_cec.send:
          source: 0x05
          destination: 0x0
          data: [ 0x04 ]
      - logger.log: "Button pressed"

# Enable Home Assistant API
# api:
  # services:
  #   - service: transmit_cec
  #     variables:
  #       source: int
  #       destination: int
  #       data: int[]
  #     then:
  #       - hdmi_cec.send:
  #           # source: !lambda 'return source;'
  #           destination: !lambda 'return destination;'
  #           data: !lambda 'return data;'

    # I'm not sure how to use jinja {% if %} statements and return an int,
    # So instead I'm using an alternate method that accepts a string for command
  #   - service: transmit_nec_string
  #     variables:
  #       address: int
  #       command: string
  #     then:
  #       - remote_transmitter.transmit_nec:
  #           address: !lambda 'return address;'
  #           command: !lambda 'return (int)strtol(command.c_str(), NULL, 16);'
  #   - service: transmit_raw
  #     variables:
  #       code: int[]
  #       carrier_frequency: float
  #     then:
  #       - remote_transmitter.transmit_raw:
  #           code: !lambda 'return code;'
  #           carrier_frequency: !lambda 'return carrier_frequency;'
  #   - service: transmit_raw_repeat
  #     variables:
  #       code: int[]
  #       carrier_frequency: float
  #       repeat_times: int
  #       repeat_wait_time_us: int
  #     then:
  #       - remote_transmitter.transmit_raw:
  #           code: !lambda 'return code;'
  #           carrier_frequency: !lambda 'return carrier_frequency;'
  #           repeat:
  #             times: !lambda 'return repeat_times;'
  #             wait_time: !lambda 'return repeat_wait_time_us;'
